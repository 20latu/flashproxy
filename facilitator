#!/usr/bin/env python

import SocketServer
import getopt
import os
import re
import socket
import sys
import threading
import time

LISTEN_ADDRESS = "127.0.0.1"
DEFAULT_LISTEN_PORT = 9002
DEFAULT_RELAY_PORT = 9001
DEFAULT_LOG_FILENAME = "facilitator.log"

LOG_DATE_FORMAT = "%Y-%m-%d %H:%M:%S"

class options(object):
    listen_port = DEFAULT_LISTEN_PORT
    log_filename = DEFAULT_LOG_FILENAME
    log_file = sys.stdout
    relay_spec = None
    daemonize = True
    pid_filename = None
    safe_logging = True

    @staticmethod
    def set_relay_spec(spec):
        af, host, port = parse_addr_spec(spec, defport = DEFAULT_RELAY_PORT)
        # Resolve to get an IP address.
        addrs = socket.getaddrinfo(host, port, af)
        options.relay_spec = format_addr(addrs[0][4])

def usage(f = sys.stdout):
    print >> f, """\
Usage: %(progname)s -r RELAY <OPTIONS>
Flash proxy facilitator: Register client addresses and serve them out
again. Listen on 127.0.0.1 and port PORT (by default %(port)d).
  -d, --debug             don't daemonize, log to stdout.
  -h, --help              show this help.
  -l, --log FILENAME      write log to FILENAME (default \"%(log)s\").
  -p, --port PORT         listen on PORT (by default %(port)d).
      --pidfile FILENAME  write PID to FILENAME after daemonizing.
  -r, --relay RELAY       send RELAY (host:port) to proxies as the relay to use.
      --unsafe-logging    don't scrub IP addresses from logs.\
""" % {
    "progname": sys.argv[0],
    "port": DEFAULT_LISTEN_PORT,
    "log": DEFAULT_LOG_FILENAME,
}

log_lock = threading.Lock()
def log(msg):
    log_lock.acquire()
    try:
        print >> options.log_file, (u"%s %s" % (time.strftime(LOG_DATE_FORMAT), msg)).encode("UTF-8")
        options.log_file.flush()
    finally:
        log_lock.release()

def parse_addr_spec(spec, defhost = None, defport = None):
    host = None
    port = None
    m = None
    # IPv6 syntax.
    if not m:
        m = re.match(ur'^\[(.+)\]:(\d+)$', spec)
        if m:
            host, port = m.groups()
            af = socket.AF_INET6
    if not m:
        m = re.match(ur'^\[(.+)\]:?$', spec)
        if m:
            host, = m.groups()
            af = socket.AF_INET6
    # IPv4 syntax.
    if not m:
        m = re.match(ur'^(.+):(\d+)$', spec)
        if m:
            host, port = m.groups()
            af = socket.AF_INET
    if not m:
        m = re.match(ur'^:?(\d+)$', spec)
        if m:
            port, = m.groups()
            af = 0
    if not m:
        host = spec
        af = 0
    host = host or defhost
    port = port or defport
    if not (host and port):
        raise ValueError("Bad address specification \"%s\"" % spec)
    return af, host, int(port)

def format_addr(addr):
    host, port = addr
    if not host:
        return u":%d" % port
    # Numeric IPv6 address?
    try:
        addrs = socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_NUMERICHOST)
        af = addrs[0][0]
    except socket.gaierror, e:
        af = 0
    if af == socket.AF_INET6:
        return u"[%s]:%d" % (host, port)
    else:
        return u"%s:%d" % (host, port)

class Handler(SocketServer.StreamRequestHandler):
    def handle(self):
        self.connection.settimeout(1.0)
        while True:
            data = self.connection.recv(1024)
            print repr(data)

class Server(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    allow_reuse_address = True

def main():
    opts, args = getopt.gnu_getopt(sys.argv[1:], "dhl:p:r:",
        ["debug", "help", "log=", "port=", "pidfile=", "relay=", "unsafe-logging"])
    for o, a in opts:
        if o == "-d" or o == "--debug":
            options.daemonize = False
            options.log_filename = None
        elif o == "-h" or o == "--help":
            usage()
            sys.exit()
        elif o == "-l" or o == "--log":
            options.log_filename = a
        elif o == "-p" or o == "--port":
            options.listen_port = int(a)
        elif o == "--pidfile":
            options.pid_filename = a
        elif o == "-r" or o == "--relay":
            try:
                options.set_relay_spec(a)
            except socket.gaierror, e:
                print >> sys.stderr, u"Can't resolve relay %s: %s" % (repr(a), str(e))
                sys.exit(1)
        elif o == "--unsafe-logging":
            options.safe_logging = False

    if not options.relay_spec:
        print >> sys.stderr, """\
The -r option is required. Give it the relay that will be sent to proxies.
  -r HOST[:PORT]\
    """
        sys.exit(1)

    if options.log_filename:
        options.log_file = open(options.log_filename, "a")
        # Send error tracebacks to the log.
        sys.stderr = options.log_file
    else:
        options.log_file = sys.stdout

    addrinfo = socket.getaddrinfo(LISTEN_ADDRESS, options.listen_port, 0, socket.SOCK_STREAM, socket.IPPROTO_TCP)[0]

    server = Server(addrinfo[4], Handler)

    log(u"start on %s" % format_addr(addrinfo[4]))
    log(u"using relay address %s" % options.relay_spec)

    if options.daemonize:
        log(u"daemonizing")
        pid = os.fork()
        if pid != 0:
            if options.pid_filename:
                f = open(options.pid_filename, "w")
                print >> f, pid
                f.close()
            sys.exit(0)

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == "__main__":
    main()
