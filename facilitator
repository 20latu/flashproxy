#!/usr/bin/env python

import SocketServer
import getopt
import os
import re
import socket
import sys
import threading
import time

LISTEN_ADDRESS = "127.0.0.1"
DEFAULT_LISTEN_PORT = 9002
DEFAULT_RELAY_PORT = 9001
DEFAULT_LOG_FILENAME = "facilitator.log"

# Don't indulge clients for more than this many seconds.
CLIENT_TIMEOUT = 1.0
# Buffer no many than this many bytes when trying to read a line.
READLINE_MAX_LENGTH = 10240

LOG_DATE_FORMAT = "%Y-%m-%d %H:%M:%S"

class options(object):
    listen_port = DEFAULT_LISTEN_PORT
    log_filename = DEFAULT_LOG_FILENAME
    log_file = sys.stdout
    relay_spec = None
    daemonize = True
    pid_filename = None
    safe_logging = True

    @staticmethod
    def set_relay_spec(spec):
        af, host, port = parse_addr_spec(spec, defport = DEFAULT_RELAY_PORT)
        # Resolve to get an IP address.
        addrs = socket.getaddrinfo(host, port, af)
        options.relay_spec = format_addr(addrs[0][4])

def usage(f = sys.stdout):
    print >> f, """\
Usage: %(progname)s -r RELAY <OPTIONS>
Flash proxy facilitator: Register client addresses and serve them out
again. Listen on 127.0.0.1 and port PORT (by default %(port)d).
  -d, --debug             don't daemonize, log to stdout.
  -h, --help              show this help.
  -l, --log FILENAME      write log to FILENAME (default \"%(log)s\").
  -p, --port PORT         listen on PORT (by default %(port)d).
      --pidfile FILENAME  write PID to FILENAME after daemonizing.
  -r, --relay RELAY       send RELAY (host:port) to proxies as the relay to use.
      --unsafe-logging    don't scrub IP addresses from logs.\
""" % {
    "progname": sys.argv[0],
    "port": DEFAULT_LISTEN_PORT,
    "log": DEFAULT_LOG_FILENAME,
}

def safe_str(s):
    """Return s if options.safe_logging is true, and "[scrubbed]" otherwise."""
    if options.safe_logging:
        return "[scrubbed]"
    else:
        return s

log_lock = threading.Lock()
def log(msg):
    log_lock.acquire()
    try:
        print >> options.log_file, (u"%s %s" % (time.strftime(LOG_DATE_FORMAT), msg)).encode("UTF-8")
        options.log_file.flush()
    finally:
        log_lock.release()

def parse_addr_spec(spec, defhost = None, defport = None):
    host = None
    port = None
    m = None
    # IPv6 syntax.
    if not m:
        m = re.match(ur'^\[(.+)\]:(\d+)$', spec)
        if m:
            host, port = m.groups()
            af = socket.AF_INET6
    if not m:
        m = re.match(ur'^\[(.+)\]:?$', spec)
        if m:
            host, = m.groups()
            af = socket.AF_INET6
    # IPv4 syntax.
    if not m:
        m = re.match(ur'^(.+):(\d+)$', spec)
        if m:
            host, port = m.groups()
            af = socket.AF_INET
    if not m:
        m = re.match(ur'^:?(\d+)$', spec)
        if m:
            port, = m.groups()
            af = 0
    if not m:
        host = spec
        af = 0
    host = host or defhost
    port = port or defport
    if not (host and port):
        raise ValueError("Bad address specification \"%s\"" % spec)
    return af, host, int(port)

def format_addr(addr):
    host, port = addr
    if not host:
        return u":%d" % port
    # Numeric IPv6 address?
    try:
        addrs = socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_NUMERICHOST)
        af = addrs[0][0]
    except socket.gaierror, e:
        af = 0
    if af == socket.AF_INET6:
        return u"[%s]:%d" % (host, port)
    else:
        return u"%s:%d" % (host, port)

def skip_space(pos, line):
    """Skip a (possibly empty) sequence of space characters (the ASCII character
    '\x20' exactly). Returns a pair (pos, num_skipped)."""
    begin = pos
    while pos < len(line) and line[pos] == "\x20":
        pos += 1
    return pos, pos - begin

TOKEN_CHARS = set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-")
def get_token(pos, line):
    begin = pos
    while pos < len(line) and line[pos] in TOKEN_CHARS:
        pos += 1
    if begin == pos:
        raise ValueError("No token found at position %d" % pos)
    return pos, line[begin:pos]

def get_quoted_string(pos, line):
    chars = []
    if not (pos < len(line) and line[pos] == '"'):
        raise ValueError("Expected '\"' at beginning of quoted string.")
    pos += 1
    while pos < len(line) and line[pos] != '"':
        if line[pos] == '\\':
            pos += 1
            if not (pos < len(line)):
                raise ValueError("End of line after backslash in quoted string")
        chars.append(line[pos])
        pos += 1
    if not (pos < len(line) and line[pos] == '"'):
        raise ValueError("Expected '\"' at end of quoted string.")
    pos += 1
    return pos, "".join(chars)

def parse_command(line):
    """A line is a command followed by zero or more key-value pairs. Like so:
      COMMAND KEY="VALUE" KEY="\"ESCAPED\" VALUE"
    Values must be quoted. Any byte value may be escaped with a backslash.
    Returns a pair: (COMMAND, ((KEY1, VALUE1), (KEY2, VALUE2), ...)).
    """
    pos = 0
    pos, skipped = skip_space(pos, line)
    pos, command = get_token(pos, line)

    pairs = []
    while True:
        pos, skipped = skip_space(pos, line)
        if not (pos < len(line)):
            break
        if skipped == 0:
            raise ValueError("Expected space before key-value pair")
        pos, key = get_token(pos, line)
        if not (pos < len(line) and line[pos] == '='):
            raise ValueError("No '=' found after key")
        pos += 1
        pos, value = get_quoted_string(pos, line)
        pairs.append((key, value))
    return command, tuple(pairs)

def param_first(key, params):
    for k, v in params:
        if key == k:
            return v
    return None

def quote_string(s):
    chars = []
    for c in s:
        if c == "\\":
            c = "\\\\"
        elif c == "\"":
            c = "\\\""
        chars.append(c)
    return "\"" + "".join(chars) + "\""

def render_params(params):
    parts = []
    for key, value in params:
        parts.append("%s=%s" % (key, quote_string(value)))
    return " ".join(parts)

class TCPReg(object):
    def __init__(self, host, port):
        self.host = host
        self.port = port

    def __unicode__(self):
        return format_addr((self.host, self.port))

    def __str__(self):
        return unicode(self).encode("UTF-8")

    def __cmp__(self, other):
        if isinstance(other, TCPReg):
            return cmp((self.host, self.port), (other.host, other.port))
        else:
            return False

class Reg(object):
    @staticmethod
    def parse(spec, defhost = None, defport = None):
        try:
            af, host, port = parse_addr_spec(spec, defhost, defport)
        except ValueError:
            pass
        else:
            try:
                addrs = socket.getaddrinfo(host, port, af, socket.SOCK_STREAM, socket.IPPROTO_TCP, socket.AI_NUMERICHOST)
            except socket.gaierror, e:
                raise ValueError("Bad host or port: \"%s\" \"%s\": %s" % (host, port, str(e)))
            if not addrs:
                raise ValueError("Bad host or port: \"%s\" \"%s\"" % (host, port))

            host, port = socket.getnameinfo(addrs[0][4], socket.NI_NUMERICHOST | socket.NI_NUMERICSERV)
            return TCPReg(host, int(port))

        raise ValueError("Bad spec format: %s" % repr(spec))

class RegSet(object):
    def __init__(self):
        self.set = []
        self.cv = threading.Condition()

    def add(self, reg):
        self.cv.acquire()
        try:
            if reg not in list(self.set):
                self.set.append(reg)
                self.cv.notify()
                return True
            else:
                return False
        finally:
            self.cv.release()

    def fetch(self):
        self.cv.acquire()
        try:
            if not self.set:
                return None
            return self.set.pop(0)
        finally:
            self.cv.release()

    def __len__(self):
        self.cv.acquire()
        try:
            return len(self.set)
        finally:
            self.cv.release()

class Handler(SocketServer.StreamRequestHandler):
    def __init__(self, *args, **kwargs):
        self.deadline = time.time() + CLIENT_TIMEOUT
        # Buffer for readline.
        self.buffer = ""
        SocketServer.StreamRequestHandler.__init__(self, *args, **kwargs)

    def recv(self):
        timeout = self.deadline - time.time()
        self.connection.settimeout(timeout)
        return self.connection.recv(1024)

    def readline(self):
        # A line already buffered?
        i = self.buffer.find("\n")
        if i >= 0:
            line = self.buffer[:i+1]
            self.buffer = self.buffer[i+1:]
            return line

        auxbuf = []
        buflen = len(self.buffer)
        while True:
            data = self.recv()
            if not data:
                if self.buffer or auxbuf:
                    raise socket.error("readline: stream does not end with a newline")
                else:
                    return ""
            i = data.find("\n")
            if i >= 0:
                line = self.buffer + "".join(auxbuf) + data[:i+1]
                self.buffer = data[i+1:]
                return line
            else:
                auxbuf.append(data)
                buflen += len(data)
                if buflen >= READLINE_MAX_LENGTH:
                    raise socket.error("readline: refusing to buffer %d bytes (last read was %d bytes)" % (buflen, len(data)))

    def handle(self):
        num_lines = 0
        while True:
            try:
                line = self.readline()
                if not line:
                    break
                num_lines += 1
            except socket.error, e:
                log("socket error after reading %d lines: %s" % (num_lines, str(e)))
                break
            if not self.handle_line(line):
                break

    def handle_line(self, line):
        if not (len(line) > 0 and line[-1] == '\n'):
            raise ValueError("No newline at end of string returned by readline")
        try:
            command, params = parse_command(line[:-1])
        except ValueError, e:
            log("parse_command: %s" % e)
            self.send_error()
            return False

        if command == "GET":
            return self.do_GET(params)
        if command == "PUT":
            return self.do_PUT(params)
        else:
            self.send_error()
            return False

    def send_ok(self):
        print >> self.wfile, "OK"

    def send_error(self):
        print >> self.wfile, "ERROR"

    def do_GET(self, params):
        reg = REGS.fetch()
        if reg:
            log(u"proxy gets %s, relay %s (now %d)" %
                (safe_str(unicode(reg)), options.relay_spec, len(REGS)))
            print >> self.wfile, "OK", render_params((("CLIENT", str(reg)), ("RELAY", options.relay_spec)))
        else:
            log(u"proxy gets none")
            print >> self.wfile, "NONE"
        return True

    def do_PUT(self, params):
        client_spec = param_first("CLIENT", params)
        if client_spec is None:
            log(u"PUT missing CLIENT param")
            self.send_error()
            return False

        # FROM

        try:
            reg = Reg.parse(client_spec, self.client_address[0])
        except ValueError, e:
            log(u"syntax error in %s: %s" % (safe_str(repr(client_spec)), repr(str(e))))
            self.send_error()
            return False

        if REGS.add(reg):
            log(u"client %s (now %d)" % (safe_str(unicode(reg)), len(REGS)))
        else:
            log(u"client %s (already present, now %d)" % (safe_str(unicode(reg)), len(REGS)))

        self.send_ok()
        return True

class Server(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    allow_reuse_address = True

REGS = RegSet()

def main():
    opts, args = getopt.gnu_getopt(sys.argv[1:], "dhl:p:r:",
        ["debug", "help", "log=", "port=", "pidfile=", "relay=", "unsafe-logging"])
    for o, a in opts:
        if o == "-d" or o == "--debug":
            options.daemonize = False
            options.log_filename = None
        elif o == "-h" or o == "--help":
            usage()
            sys.exit()
        elif o == "-l" or o == "--log":
            options.log_filename = a
        elif o == "-p" or o == "--port":
            options.listen_port = int(a)
        elif o == "--pidfile":
            options.pid_filename = a
        elif o == "-r" or o == "--relay":
            try:
                options.set_relay_spec(a)
            except socket.gaierror, e:
                print >> sys.stderr, u"Can't resolve relay %s: %s" % (repr(a), str(e))
                sys.exit(1)
        elif o == "--unsafe-logging":
            options.safe_logging = False

    if not options.relay_spec:
        print >> sys.stderr, """\
The -r option is required. Give it the relay that will be sent to proxies.
  -r HOST[:PORT]\
    """
        sys.exit(1)

    if options.log_filename:
        options.log_file = open(options.log_filename, "a")
        # Send error tracebacks to the log.
        sys.stderr = options.log_file
    else:
        options.log_file = sys.stdout

    addrinfo = socket.getaddrinfo(LISTEN_ADDRESS, options.listen_port, 0, socket.SOCK_STREAM, socket.IPPROTO_TCP)[0]

    server = Server(addrinfo[4], Handler)

    log(u"start on %s" % format_addr(addrinfo[4]))
    log(u"using relay address %s" % options.relay_spec)

    if options.daemonize:
        log(u"daemonizing")
        pid = os.fork()
        if pid != 0:
            if options.pid_filename:
                f = open(options.pid_filename, "w")
                print >> f, pid
                f.close()
            sys.exit(0)

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == "__main__":
    main()
